<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Car Physics Simulator</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      background: linear-gradient(135deg, #667eea, #764ba2);
      padding: 20px;
      color: #333;
    }
    .road-container {
      position: relative;
      height: 150px;
      background: #87ceeb;
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 20px;
    }
    .road {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 40%;
      background: #444;
      background-image: repeating-linear-gradient(
        90deg,
        transparent,
        transparent 30px,
        white 30px,
        white 40px
      );
    }
    .car {
      position: absolute;
      bottom: 5%;
      left: 50px;
      width: 120px;
      height: 75px;
      z-index: 10;
      filter: drop-shadow(0 5px 10px rgba(0, 0, 0, 0.3));
      transition: left 0.1s linear;
    }
    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    label {
      font-weight: bold;
    }
    input[type='range'],
    input[type='number'] {
      width: 100%;
      padding: 5px;
      border-radius: 5px;
      border: 1px solid #ccc;
    }
    .buttons {
      text-align: center;
      margin-bottom: 20px;
    }
    button {
      margin: 0 5px;
      padding: 10px 20px;
      font-size: 16px;
      cursor: pointer;
    }
    .simulation-area {
      background: rgba(255, 255, 255, 0.9);
      padding: 15px;
      border-radius: 10px;
    }
    .dot-diagram {
      height: 100px;
      background: white;
      border: 2px solid #333;
      border-radius: 8px;
      margin-bottom: 20px;
      position: relative;
      overflow: hidden;
    }
    .dot {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #f44;
      border-radius: 50%;
      top: 50%;
      transform: translateY(-50%);
    }
    .graph {
      width: 100%;
      height: 200px;
      background: #f9f9f9;
      border: 1px solid #333;
    }
    @media (max-width: 600px) {
      .controls {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <h1>Driving with Skaphysics</h1>

  <div class="road-container">
  <div class="road"></div>
  <svg class="car" viewBox="0 0 300 200" width="200" height="120">
  <!-- Wheels -->
  <ellipse cx="80" cy="150" rx="25" ry="12" fill="#333" />
  <ellipse cx="220" cy="150" rx="25" ry="12" fill="#333" />

  <!-- Car base -->
  <rect x="50" y="100" width="200" height="40" rx="10" fill="#f44" />

  <!-- Car top (rounded roof) -->
  <path d="M80,100 Q150,40 220,100 Z" fill="#f44" />

  <!-- Light blue window -->
  <path d="M100,100 Q150,55 200,100 Z" fill="lightblue" opacity="0.7" />

  <!-- Head (comically large) -->
  <g id="headGroup" transform="translate(115, 10)">
    <image
      id="faceImage"
      href="https://raw.githubusercontent.com/makeshiftdevan/skaphysics/main/assets/face.png"
      x="0"
      y="0"
      width="100"
      height="100"
      preserveAspectRatio="xMidYMid meet"
    />
  </g>
</svg>
</div>

  <div class="controls">
    <div class="control-group">
      <label for="initialVelocityRange">Initial Velocity (m/s)</label>
      <input
        type="range"
        id="initialVelocityRange"
        min="-20"
        max="20"
        step="1"
        value="10"
      />
      <input type="number" id="initialVelocityNum" value="10" step="1" />
    </div>
    <div class="control-group">
      <label for="accelerationRange">Acceleration (m/s¬≤)</label>
      <input
        type="range"
        id="accelerationRange"
        min="-10"
        max="10"
        step="0.5"
        value="2"
      />
      <input type="number" id="accelerationNum" value="2" step="0.5" />
    </div>
    <div class="control-group">
      <label for="runTimeRange">Run Time (s)</label>
      <input type="range" id="runTimeRange" min="1" max="20" step="1" value="5" />
      <input type="number" id="runTimeNum" value="5" step="1" />
    </div>
  </div>

  <div class="buttons">
    <button id="playBtn">‚ñ∂ Play</button>
    <button id="pauseBtn">‚è∏ Pause</button>
    <button id="resetBtn">üîÑ Reset</button>
  </div>

  <div class="simulation-area">
    <div id="status">Ready to simulate</div>
    <div class="dot-diagram" id="dotDiagram"></div>
    <canvas id="positionGraph" class="graph" width="600" height="200"></canvas>
    <canvas id="velocityGraph" class="graph" width="600" height="200"></canvas>
    <canvas id="accelerationGraph" class="graph" width="600" height="200"></canvas>
  </div>

  <script>
    let animationId;
    let isRunning = false;
    let isPaused = false;
    let startTime;
    let pausedTime = 0;
    let currentTime = 0;

    let initialVelocity = 10;
    let acceleration = 2;
    let runTime = 10;

    let positionData = [];
    let velocityData = [];
    let accelerationData = [];
    let timeData = [];

    let maxExpectedPosition = 100;
    let maxExpectedVelocity = 10;
    let maxExpectedAcceleration = 10;

    function syncInputs() {
      const pairs = [
        ['accelerationNum', 'accelerationRange'],
        ['runTimeNum', 'runTimeRange'],
        ['initialVelocityNum', 'initialVelocityRange'],
      ];
      pairs.forEach(([numId, rangeId]) => {
        document.getElementById(numId).addEventListener('input', (e) => {
          document.getElementById(rangeId).value = e.target.value;
          updateValues();
        });
        document.getElementById(rangeId).addEventListener('input', (e) => {
          document.getElementById(numId).value = e.target.value;
          updateValues();
        });
      });
    }

    function updateValues() {
      initialVelocity =
        parseFloat(document.getElementById('initialVelocityNum')?.value) || 10;
      acceleration = parseFloat(document.getElementById('accelerationNum')?.value) || 2;
      runTime = parseFloat(document.getElementById('runTimeNum')?.value) || 10;
    }

    function startSimulation() {
      if (isPaused) {
        isPaused = false;
        startTime = Date.now() - pausedTime;
      } else {
        resetSimulation();
        updateValues();
        startTime = Date.now();
        pausedTime = 0;
        positionData = [];
        velocityData = [];
        accelerationData = [];
        timeData = [];
      }
      isRunning = true;
      document.getElementById('status').textContent = 'Simulation Running...';

      maxExpectedPosition = initialVelocity * runTime + 0.5 * acceleration * runTime ** 2;
      maxExpectedVelocity = Math.max(
        Math.abs(initialVelocity),
        Math.abs(initialVelocity + acceleration * runTime)
      );
      maxExpectedAcceleration = Math.abs(acceleration); // constant here
maxExpectedPosition = initialVelocity * runTime + 0.5 * acceleration * runTime ** 2;
maxExpectedVelocity = Math.abs(initialVelocity + acceleration * runTime);
maxExpectedAcceleration = Math.abs(acceleration); // constant in this case
      animate();
    }

    function pauseSimulation() {
      if (isRunning) {
        isRunning = false;
        isPaused = true;
        pausedTime = Date.now() - startTime;
        cancelAnimationFrame(animationId);
        document.getElementById('status').textContent = 'Simulation Paused';
      }
    }

    function resetSimulation() {
      isRunning = false;
      isPaused = false;
      currentTime = 0;
      pausedTime = 0;
      cancelAnimationFrame(animationId);
      document.querySelector('.car').style.left = '50px';

      clearGraphs();
      document.getElementById('dotDiagram').innerHTML = '';
      document.getElementById('status').textContent = 'Ready to simulate';

      positionData = [];
      velocityData = [];
      accelerationData = [];
      timeData = [];
    }

   function animate() {
  if (!isRunning) return;
  currentTime = (Date.now() - startTime) / 1000;
  if (currentTime > runTime) {
    isRunning = false;
    document.getElementById('status').textContent = 'Simulation Complete';
    return;
  }

      const position = initialVelocity * currentTime + 0.5 * acceleration * currentTime ** 2;
      const velocity = initialVelocity + acceleration * currentTime;
      const currentAcceleration = acceleration;

      const carElement = document.querySelector('.car');
      const roadWidth = document.querySelector('.road-container').offsetWidth;
      const carPosition = 50 + (position * 2) % (roadWidth - 100);
      carElement.style.left = carPosition + 'px';

      const tilt = -acceleration * 4;
      const headGroup = document.getElementById('headGroup');
      headGroup.setAttribute('transform', `translate(115, 40) rotate(${tilt}, 30, 55)`);

      positionData.push(position);
      velocityData.push(velocity);
      accelerationData.push(currentAcceleration);
      timeData.push(currentTime);

      document.getElementById('status').innerHTML =
        `Time: ${currentTime.toFixed(1)}s | ` +
        `Position: ${position.toFixed(1)}m | ` +
        `Velocity: ${velocity.toFixed(1)}m/s | ` +
        `Acceleration: ${currentAcceleration.toFixed(1)}m/s¬≤`;

      updateDotDiagram(currentTime, position);
      updateGraphs();

      animationId = requestAnimationFrame(animate);
    }

    function updateDotDiagram(time, position) {
      const dotDiagram = document.getElementById('dotDiagram');
      const diagramWidth = dotDiagram.offsetWidth - 40;
      if (Math.floor(time * 2) > dotDiagram.querySelectorAll('.dot').length) {
        const dot = document.createElement('div');
        dot.className = 'dot';
        const dotPosition = 20 + (position * 2) % (diagramWidth - 20);
        dot.style.left = dotPosition + 'px';
        dotDiagram.appendChild(dot);
      }
    }

    function updateGraphs() {
      updatePositionGraph();
      updateVelocityGraph();
      updateAccelerationGraph();
    }

    function drawLabels(ctx, canvas, xLabel, yLabel) {
      ctx.fillStyle = '#000';
      ctx.font = '14px sans-serif';

      // X-axis label
      ctx.textAlign = 'center';
      ctx.fillText(xLabel, canvas.width / 2, canvas.height - 5);

      // Y-axis label (rotated)
      ctx.save();
      ctx.translate(10, canvas.height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = 'center';
      ctx.fillText(yLabel, 0, 0);
      ctx.restore();
    }

    function drawGrid(ctx, canvas) {
      ctx.strokeStyle = '#ddd';
      ctx.lineWidth = 1;

      // Vertical lines
      for (let i = 0; i <= 10; i++) {
        const x = (i / 10) * (canvas.width - 40) + 20;
        ctx.beginPath();
        ctx.moveTo(x, 10);
        ctx.lineTo(x, canvas.height - 10);
        ctx.stroke();
      }

      // Horizontal lines
      for (let i = 0; i <= 8; i++) {
        const y = (i / 8) * (canvas.height - 40) + 20;
        ctx.beginPath();
        ctx.moveTo(10, y);
        ctx.lineTo(canvas.width - 10, y);
        ctx.stroke();
      }
    }

   function updatePositionGraph() {
  const canvas = document.getElementById('positionGraph');
  const ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  if (timeData.length < 2) return;

  drawGrid(ctx, canvas);

  const minPos = Math.min(...positionData, 0);
  const maxPos = Math.max(1, maxExpectedPosition);
  const padding = 5;
  const yMin = minPos - padding;
  const yMax = maxPos + padding;
  const yRange = yMax - yMin;

  // Draw position curve
  ctx.strokeStyle = '#2196F3'; // blue
  ctx.lineWidth = 3;
  ctx.beginPath();
  for (let i = 0; i < timeData.length; i++) {
    const x = (timeData[i] / runTime) * (canvas.width - 40) + 20;
    const y = canvas.height - 20 - ((positionData[i] - yMin) / yRange) * (canvas.height - 40);
    if (i === 0) ctx.moveTo(x, y);
    else ctx.lineTo(x, y);
  }
  ctx.stroke();

  drawLabels(ctx, canvas, 'Time (s)', 'Position (m)');
}


    function updateVelocityGraph() {
      const canvas = document.getElementById('velocityGraph');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (timeData.length < 2) return;

      drawGrid(ctx, canvas);

      const maxVel = Math.max(1, maxExpectedVelocity);
      const zeroY = canvas.height - 20 - (maxVel / (2 * maxVel)) * (canvas.height - 40);

      // Fill area under curve (blue)
      ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
      ctx.beginPath();
      ctx.moveTo(20, zeroY);
      for (let i = 0; i < timeData.length; i++) {
        const x = (timeData[i] / runTime) * (canvas.width - 40) + 20;
        const y = canvas.height - 20 - ((velocityData[i] + maxVel) / (2 * maxVel)) * (canvas.height - 40);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(
        (timeData[timeData.length - 1] / runTime) * (canvas.width - 40) + 20,
        zeroY
      );
      ctx.fill();

      // Draw velocity line
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < timeData.length; i++) {
        const x = (timeData[i] / runTime) * (canvas.width - 40) + 20;
        const y = canvas.height - 20 - ((velocityData[i] + maxVel) / (2 * maxVel)) * (canvas.height - 40);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Draw slope indicator (green)
      if (timeData.length > 1) {
        const lastIndex = timeData.length - 1;
        const prevIndex = Math.max(0, lastIndex - 5);

        const x1 = (timeData[prevIndex] / runTime) * (canvas.width - 40) + 20;
        const x2 = (timeData[lastIndex] / runTime) * (canvas.width - 40) + 20;
        const y1 = canvas.height - 20 - ((velocityData[prevIndex] + maxVel) / (2 * maxVel)) * (canvas.height - 40);
        const y2 = canvas.height - 20 - ((velocityData[lastIndex] + maxVel) / (2 * maxVel)) * (canvas.height - 40);

        ctx.strokeStyle = '#4CAF50'; // green
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }

      drawLabels(ctx, canvas, 'Time (s)', 'Velocity (m/s)');
    }

    function updateAccelerationGraph() {
      const canvas = document.getElementById('accelerationGraph');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      if (timeData.length < 2) return;

      drawGrid(ctx, canvas);

      const maxAcc = Math.max(1, maxExpectedAcceleration);
      const zeroY = canvas.height - 20 - (maxAcc / (2 * maxAcc)) * (canvas.height - 40);

      // Fill area under curve (green)
      ctx.fillStyle = 'rgba(76, 175, 80, 0.3)';
      ctx.beginPath();
      ctx.moveTo(20, zeroY);
      for (let i = 0; i < timeData.length; i++) {
        const x = (timeData[i] / runTime) * (canvas.width - 40) + 20;
        const y = canvas.height - 20 - ((accelerationData[i] + maxAcc) / (2 * maxAcc)) * (canvas.height - 40);
        ctx.lineTo(x, y);
      }
      ctx.lineTo(
        (timeData[timeData.length - 1] / runTime) * (canvas.width - 40) + 20,
        zeroY
      );
      ctx.fill();

      // Draw acceleration line
      ctx.strokeStyle = '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < timeData.length; i++) {
        const x = (timeData[i] / runTime) * (canvas.width - 40) + 20;
        const y = canvas.height - 20 - ((accelerationData[i] + maxAcc) / (2 * maxAcc)) * (canvas.height - 40);

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();

      // Draw slope indicator (orange) - constant acceleration line
      ctx.strokeStyle = '#FF9800';
      ctx.lineWidth = 3;
      ctx.beginPath();
      const y = canvas.height - 20 - ((acceleration + maxAcc) / (2 * maxAcc)) * (canvas.height - 40);
      ctx.moveTo(20, y);
      ctx.lineTo((timeData[timeData.length - 1] / runTime) * (canvas.width - 40) + 20, y);
      ctx.stroke();

      drawLabels(ctx, canvas, 'Time (s)', 'Acceleration (m/s¬≤)');
    }

    function clearGraphs() {
      ['positionGraph', 'velocityGraph', 'accelerationGraph'].forEach((id) => {
        const c = document.getElementById(id);
        const ctx = c.getContext('2d');
        ctx.clearRect(0, 0, c.width, c.height);
      });
    }

    document.getElementById('playBtn').addEventListener('click', startSimulation);
    document.getElementById('pauseBtn').addEventListener('click', pauseSimulation);
    document.getElementById('resetBtn').addEventListener('click', resetSimulation);

    syncInputs();
    resetSimulation();
  </script>
</body>
</html>
